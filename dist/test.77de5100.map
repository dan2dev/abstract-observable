{"version":3,"sources":["../node_modules/asap/browser-raw.js","../node_modules/asap/browser-asap.js","../src/observable.ts","../src/main.ts","simple.ts","index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"test.77de5100.map","sourceRoot":"../test","sourcesContent":["\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jsâ€™s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n","\"use strict\";\n\n// rawAsap provides everything we need except exception management.\nvar rawAsap = require(\"./raw\");\n// RawTasks are recycled to reduce GC churn.\nvar freeTasks = [];\n// We queue errors to ensure they are thrown in right order (FIFO).\n// Array-as-queue is good enough here, since we are just dealing with exceptions.\nvar pendingErrors = [];\nvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\nfunction throwFirstError() {\n    if (pendingErrors.length) {\n        throw pendingErrors.shift();\n    }\n}\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawAsap(rawTask);\n}\n\n// We wrap tasks with recyclable task objects.  A task object implements\n// `call`, just like a function.\nfunction RawTask() {\n    this.task = null;\n}\n\n// The sole purpose of wrapping the task is to catch the exception and recycle\n// the task object after its single use.\nRawTask.prototype.call = function () {\n    try {\n        this.task.call();\n    } catch (error) {\n        if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n        } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n        }\n    } finally {\n        this.task = null;\n        freeTasks[freeTasks.length] = this;\n    }\n};\n","import { IObserver } from \"./interface/observer\";\nimport { IObservableData, IObservable } from \"./interface/observable\";\nimport asapCall from \"asap\";\n\nexport abstract class Observable implements IObservable {\n  private _observable: IObservableData = {\n    lastIndex: 0,\n    observers: {},\n    notifyStack: 0,\n    notifyResolve: [],\n    parent: undefined\n  };\n  private notifyAllObservers(): void {\n    for (const i in this._observable.observers) {\n      if (this._observable.observers.hasOwnProperty(i)) {\n        const holder = this._observable.observers[i];\n        if (typeof holder.notify === \"object\") {\n            (holder.notify as Observable).notify(false);\n        } else {\n            (holder as IObserver).notify();\n        }\n      }\n    }\n    const resolvers = this._observable.notifyResolve;\n    while(resolvers.length > 0) {\n      const resolve = resolvers.shift();\n      if(resolve !== undefined) {\n        resolve();\n      }\n    }\n  }\n  protected constructor(parent?: Observable);\n  protected constructor(observer?: IObserver);\n  protected constructor(...args: any[]) {\n    for (const arg of args) {\n      if (arg && typeof (arg as IObserver).notify !== \"undefined\") {\n        const parent: IObservable = (arg as IObservable);\n        if (parent) {\n          this.subscribe(parent);\n        }\n      }\n    }\n  }\n  public getRoot(): IObservable | undefined {\n    let root = this.getParent();\n    while (root !== undefined) {\n      root = this.getParent();\n    }\n    if (root === undefined) {\n      root = this;\n    }\n    return root;\n  }\n  public getParent(): IObservable | undefined {\n    return this._observable.parent;\n  }\n  public subscribe(observer: (() => void) | IObserver): () => void {\n    const currentIndex = this._observable.lastIndex++;\n    this._observable.observers[currentIndex] = {\n      index: currentIndex,\n      notify: observer,\n    };\n    // * return unsubscribe method\n    return () => {\n      delete this._observable.observers[currentIndex];\n    };\n  }\n  public async notify(asap = true): Promise<void> {\n    this._observable.notifyStack += 1;\n    return new Promise<void>((resolve, reject) => {\n      (this.getRoot() as this)._observable.notifyResolve.push(resolve);\n      const action: () => void = () => {\n          if (this._observable.notifyStack > 1) {\n              this._observable.notifyStack -= 1;\n          } else {\n              this.notifyAllObservers();\n          }\n      };\n      asap && asapCall(() => {\n        action();\n      });\n      !asap && action();\n    });\n  }\n} \n","export * from \"./observable\";\nexport * from \"./interface/observer\";\n","import { Observable, IObserver } from \"../src/main\";\n\nexport class SomeChild extends Observable {\n  public version: number = 0;\n  public async updateVersion(): Promise<void> {\n    this.version += 1;\n    this.notify();\n  }\n  public constructor(parent: Observable) {\n    super(parent);\n  }\n}\nexport class SomeRoot extends Observable {\n  public children: SomeChild[] = [];\n  public constructor() {\n    super();\n  }\n  public newChildren() {\n    this.children.push(new SomeChild(this));\n    this.notify();\n  }\n}","import {Observable, IObserver} from \"../src/main\";\nimport {SomeChild, SomeRoot} from \"./simple\";\n\n(async () => {\n    const someRoot = new SomeRoot();\n    let i: number = 0;\n    let value = \"testing\";\n    someRoot.subscribe(() => {\n        i += 1;\n        value = \"changed notify\", i;\n        console.log(\"root notified -\", i);\n    });\n    someRoot.newChildren();\n    console.log(\"---\");\n    someRoot.children[0].subscribe(() => {\n        console.log(\"children notified -\", this);\n    });\n    someRoot.children[0].updateVersion();\n    someRoot.children[0].updateVersion();\n    someRoot.children[0].updateVersion();\n    console.log(\"--- version\", someRoot.children[0].version);\n    await someRoot.notify();\n    console.log(\"after notify -\");\n    someRoot.children[0].notify();\n\n    someRoot.newChildren();\n    console.log(\"n\", 2);\n    value = \"changed 2\";\n    someRoot.newChildren();\n    console.log(\"n\", 3);\n    someRoot.newChildren();\n    console.log(value.toString(), i.toString());\n    console.log(someRoot.children.toString());\n\n\n    const teste2 = new Promise<void>(() => {\n\n    });\n})();\n"]}